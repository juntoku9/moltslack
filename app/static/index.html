<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>MoltSlack</title>
    <link rel="stylesheet" href="/static/vendor/xterm.css" />
    <style>
      :root {
        --bg: #f3f4f6;
        --panel: #ffffff;
        --text: #111827;
        --muted: #6b7280;
        --border: #d1d5db;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: ui-sans-serif, -apple-system, Segoe UI, Helvetica, Arial, sans-serif;
        background: var(--bg);
        color: var(--text);
      }
      .layout {
        display: grid;
        grid-template-columns: 230px 1fr;
        height: 100vh;
      }
      .sidebar {
        background: linear-gradient(180deg, #111827 0%, #0b1220 100%);
        color: #e5e7eb;
        padding: 12px;
        border-right: 1px solid #0f172a;
      }
      .sidebar h1 { margin: 0 0 8px; font-size: 28px; }
      .new-btn {
        width: 100%;
        border: 1px solid #374151;
        background: #2563eb;
        color: white;
        border-radius: 8px;
        padding: 8px 10px;
        cursor: pointer;
      }
      .chat-list { margin-top: 10px; display: flex; flex-direction: column; gap: 6px; }
      .chat-item {
        padding: 8px 10px;
        border-radius: 8px;
        cursor: pointer;
        border: 1px solid transparent;
      }
      .chat-item.active { background: #1f3b57; border-color: #2b5d87; }

      .main {
        display: grid;
        grid-template-rows: 48px 1fr 68px;
      }
      .topbar {
        background: var(--panel);
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 12px;
      }
      .title-row { display: flex; align-items: center; gap: 8px; }
      .hint { color: var(--muted); font-size: 12px; }
      .modes { display: flex; gap: 6px; }
      .mode-btn {
        border: 1px solid var(--border);
        border-radius: 8px;
        background: #f3f4f6;
        padding: 6px 10px;
        font-size: 12px;
        cursor: pointer;
      }
      .mode-btn.active {
        background: #0f766e;
        border-color: #0f766e;
        color: #fff;
      }
      .inline-toggle {
        border: 1px solid var(--border);
        border-radius: 8px;
        background: #fff;
        padding: 6px 10px;
        font-size: 12px;
        cursor: pointer;
      }
      .inline-toggle.on {
        background: #ecfeff;
        border-color: #14b8a6;
        color: #0f766e;
      }

      .pane {
        margin: 12px;
        border-radius: 12px;
        overflow: hidden;
        border: 1px solid #1f2937;
      }
      .terminal-pane {
        background: radial-gradient(circle at top right, #152040 0%, #0b1020 40%, #080c16 100%);
        padding: 8px;
      }
      .terminal { width: 100%; height: 100%; }

      .feed-pane {
        border-color: var(--border);
        background: #f8fafc;
        padding: 16px;
        overflow-y: auto;
      }
      .feed {
        max-width: 1200px;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .msg {
        max-width: 92%;
        border-radius: 12px;
        padding: 10px 12px;
        white-space: pre-wrap;
        word-break: break-word;
        font-size: 14px;
        line-height: 1.45;
      }
      .msg.user { align-self: flex-end; background: #dbeafe; border: 1px solid #93c5fd; }
      .msg.assistant { align-self: flex-start; background: #fff; border: 1px solid #d1d5db; }
      .msg.system { align-self: center; background: #f3f4f6; border: 1px solid #e5e7eb; color: #4b5563; font-size: 12px; }

      .act {
        background: #fff;
        border: 1px solid #e5e7eb;
        border-radius: 10px;
        padding: 8px 10px;
        font-size: 12px;
      }
      .act .ts { color: #6b7280; margin-right: 6px; }
      .act .tag {
        display: inline-block;
        padding: 1px 6px;
        border-radius: 999px;
        border: 1px solid #d1d5db;
        background: #f9fafb;
        margin-right: 6px;
      }
      .msg.inline-activity {
        align-self: flex-start;
        background: #f8fafc;
        border: 1px dashed #cbd5e1;
        color: #475569;
        font-size: 12px;
        max-width: 70%;
      }
      .msg.inline-thought {
        align-self: flex-start;
        background: #fff7ed;
        border: 1px solid #fed7aa;
        color: #9a3412;
        font-size: 12px;
        max-width: 75%;
      }

      .composer {
        display: grid;
        grid-template-columns: 1fr 100px;
        gap: 8px;
        padding: 10px 12px;
        border-top: 1px solid var(--border);
        background: var(--panel);
      }
      textarea {
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 10px;
        font-family: inherit;
        font-size: 14px;
      }
      textarea { resize: none; }
      .send {
        border: 1px solid #0f766e;
        border-radius: 8px;
        background: #0f766e;
        color: #fff;
        cursor: pointer;
      }
      .hidden { display: none; }
    </style>
  </head>
  <body>
    <div class="layout">
      <aside class="sidebar">
        <h1>MoltSlack</h1>
        <button class="new-btn" id="new-chat">+ New Chat</button>
        <div class="chat-list" id="chat-list"></div>
      </aside>

      <main class="main">
        <div class="topbar">
          <div class="title-row">
            <strong id="title">No chat selected</strong>
            <span class="hint">Chat from structured events, activity from intermediate events, terminal stays raw.</span>
          </div>
          <div class="modes">
            <button class="mode-btn active" id="mode-terminal">Terminal</button>
            <button class="mode-btn" id="mode-chat">Chat</button>
            <button class="mode-btn" id="mode-activity">Activity</button>
            <button class="inline-toggle on" id="toggle-execution">Exec: Interactive</button>
            <button class="inline-toggle on" id="toggle-inline-activity">Intermediate On</button>
          </div>
        </div>

        <div class="pane terminal-pane" id="terminal-pane"><div class="terminal" id="terminal"></div></div>
        <div class="pane feed-pane hidden" id="chat-pane"><div class="feed" id="chat-feed"></div></div>
        <div class="pane feed-pane hidden" id="activity-pane"><div class="feed" id="activity-feed"></div></div>

        <div class="composer">
          <textarea id="input" placeholder="Terminal: raw input. Chat/Activity: task run. Prefix /claude or /codex to switch agent."></textarea>
          <button class="send" id="send">Send</button>
        </div>
      </main>
    </div>

    <script src="/static/vendor/xterm.js"></script>
    <script src="/static/vendor/addon-fit.js"></script>
    <script>
      let chats = [];
      let selectedChatId = null;
      let stream = null;
      let mode = "terminal";
      let useXterm = false;
      let term = null;
      let fitAddon = null;
      let keyFlushTimer = null;
      let keyBuffer = "";
      let defaultProvider = "claude";
      let showInlineActivity = true;
      let executionMode = "interactive"; // interactive | structured
      const state = {}; // chatId -> {messages: [], activity: []}

      const chatListEl = document.getElementById("chat-list");
      const titleEl = document.getElementById("title");
      const terminalPaneEl = document.getElementById("terminal-pane");
      const chatPaneEl = document.getElementById("chat-pane");
      const activityPaneEl = document.getElementById("activity-pane");
      const terminalEl = document.getElementById("terminal");
      const chatFeedEl = document.getElementById("chat-feed");
      const activityFeedEl = document.getElementById("activity-feed");
      const inputEl = document.getElementById("input");
      const inlineToggleEl = document.getElementById("toggle-inline-activity");
      const executionToggleEl = document.getElementById("toggle-execution");

      function resolveProviderAndPrompt(raw) {
        const text = (raw || "").trim();
        if (text.toLowerCase().startsWith("/claude ")) {
          defaultProvider = "claude";
          return { provider: "claude", prompt: text.slice(8).trim() };
        }
        if (text.toLowerCase().startsWith("/codex ")) {
          defaultProvider = "codex";
          return { provider: "codex", prompt: text.slice(7).trim() };
        }
        return { provider: defaultProvider, prompt: text };
      }

      function getState(chatId) {
        if (!state[chatId]) {
          state[chatId] = {
            messages: [],
            activity: [],
            timeline: [],
            lastThought: "",
            lastUserInput: "",
            turnBuffer: "",
            turnDraftMsgIdx: -1,
            turnDraftTimelineIdx: -1,
            turnUpdateTimer: null,
            turnFinalizeTimer: null,
            turnActive: false,
          };
        }
        return state[chatId];
      }

      function fmtTs(ms) {
        const d = new Date(ms || Date.now());
        return d.toLocaleTimeString();
      }

      function pushMessage(chatId, role, text, provider, ts) {
        if (!chatId || !text || !text.trim()) return;
        const s = getState(chatId);
        const entry = { role, text: text.trim(), provider: provider || "", ts: ts || Date.now() };
        s.messages.push(entry);
        s.timeline.push({ kind: "chat", ...entry });
        if (s.messages.length > 400) s.messages = s.messages.slice(-400);
        if (s.timeline.length > 1400) s.timeline = s.timeline.slice(-1400);
        if (chatId === selectedChatId && mode === "chat") renderChat();
      }

      function pushActivity(chatId, detail, provider, stage, ts) {
        if (!chatId || !detail) return;
        const s = getState(chatId);
        const entry = { detail, provider: provider || "", stage: stage || "stream", ts: ts || Date.now() };
        s.activity.push(entry);
        if (s.activity.length > 800) s.activity = s.activity.slice(-800);
        if (chatId === selectedChatId && mode === "activity") renderActivity();
      }

      function pushThought(chatId, text, provider, ts) {
        const clean = (text || "").trim();
        if (!clean) return;
        const s = getState(chatId);
        if (s.lastThought === clean) return;
        s.lastThought = clean;
        s.timeline.push({ kind: "thought", text: clean, provider: provider || "agent", ts: ts || Date.now() });
        if (s.timeline.length > 1400) s.timeline = s.timeline.slice(-1400);
        if (chatId === selectedChatId && mode === "chat" && showInlineActivity) renderChat();
      }

      function normalizeInteractiveText(text) {
        return (text || "")
          .replace(/\x1b\][^\x07]*(\x07|\x1b\\)/g, "")
          .replace(/\x1b\[[0-?]*[ -/]*[@-~]/g, "")
          .replace(/\x1b[@-_]/g, "")
          .replace(/[\x00-\x08\x0b-\x1a\x1c-\x1f\x7f]/g, "")
          .replace(/\r/g, "");
      }

      function normalizeInteractiveReply(chatId, text) {
        const s = getState(chatId);
        const user = (s.lastUserInput || "").trim().toLowerCase();
        const lines = normalizeInteractiveText(text)
          .split("\n")
          .map((l) => l.replace(/[┌┐└┘├┤┬┴┼╭╮╯╰═─━│┃╎]/g, " ").trim())
          .filter((l) => l.length > 0)
          .filter((l) => !/^[\w.@~/: -]*[%$#]\s*$/.test(l))
          .filter((l) => !/^[>\-_=|.]+$/.test(l))
          .filter((l) => !/^claude\s*$/i.test(l))
          .filter((l) => !/^codex\s*$/i.test(l))
          .filter((l) => !/^tips\s+for\s+getting\s+started/i.test(l))
          .filter((l) => !/^recent\s+activity/i.test(l))
          .filter((l) => !/^\?\s*for\s*shortcuts/i.test(l))
          .filter((l) => !/^\/ide\s+for\s+/i.test(l))
          .filter((l) => {
            const canonical = l.toLowerCase().replace(/^[^a-z0-9]*(?:[\w.@~/: -]*[%$#]\s*)?/, "").trim();
            if (!canonical) return false;
            if (user && canonical === user) return false;
            if (user && canonical.endsWith(user)) return false;
            return true;
          });

        // Reduce repeated repaint noise from full-screen TUIs.
        const counts = new Map();
        const compact = [];
        for (const line of lines) {
          const key = line.toLowerCase();
          const n = (counts.get(key) || 0) + 1;
          counts.set(key, n);
          if (n > 2) continue;
          if (compact.length > 0 && compact[compact.length - 1] === line) continue;
          compact.push(line);
        }

        const block = compact.join("\n").trim();
        if (/tips\s*for\s*getting\s*started/i.test(block) && /recent\s*activity/i.test(block)) return "";
        return block;
      }

      function commitInteractiveDraft(chatId, finalize) {
        const s = getState(chatId);
        if (s.turnUpdateTimer) {
          clearTimeout(s.turnUpdateTimer);
          s.turnUpdateTimer = null;
        }
        const block = normalizeInteractiveReply(chatId, s.turnBuffer || "");
        if (!block.trim()) return;
        if (s.turnDraftMsgIdx < 0 || s.turnDraftTimelineIdx < 0) {
          const entry = { role: "assistant", text: block, provider: "interactive", ts: Date.now(), draft: !finalize };
          s.messages.push(entry);
          s.timeline.push({ kind: "chat", ...entry });
          s.turnDraftMsgIdx = s.messages.length - 1;
          s.turnDraftTimelineIdx = s.timeline.length - 1;
        } else {
          s.messages[s.turnDraftMsgIdx].text = block;
          s.messages[s.turnDraftMsgIdx].draft = !finalize;
          s.timeline[s.turnDraftTimelineIdx].text = block;
          s.timeline[s.turnDraftTimelineIdx].draft = !finalize;
        }
        if (finalize) {
          s.turnActive = false;
          s.turnBuffer = "";
          s.turnDraftMsgIdx = -1;
          s.turnDraftTimelineIdx = -1;
          if (s.turnFinalizeTimer) {
            clearTimeout(s.turnFinalizeTimer);
            s.turnFinalizeTimer = null;
          }
        }
        if (chatId === selectedChatId && mode === "chat") renderChat();
      }

      function beginInteractiveTurn(chatId, userText) {
        const s = getState(chatId);
        if (s.turnActive) commitInteractiveDraft(chatId, true);
        s.turnActive = true;
        s.turnBuffer = "";
        s.turnDraftMsgIdx = -1;
        s.turnDraftTimelineIdx = -1;
        s.lastUserInput = (userText || "").trim();
      }

      function mirrorInteractiveOutput(chatId, chunk) {
        const s = getState(chatId);
        if (!s.turnActive) {
          s.turnActive = true;
        }
        s.turnBuffer += chunk || "";
        if (s.turnUpdateTimer) clearTimeout(s.turnUpdateTimer);
        s.turnUpdateTimer = setTimeout(() => commitInteractiveDraft(chatId, false), 300);
        if (s.turnFinalizeTimer) clearTimeout(s.turnFinalizeTimer);
        s.turnFinalizeTimer = setTimeout(() => commitInteractiveDraft(chatId, true), 1500);
      }

      function renderChat() {
        chatFeedEl.innerHTML = "";
        if (!selectedChatId) return;
        const timeline = getState(selectedChatId).timeline;
        for (const item of timeline) {
          if (item.kind === "chat") {
            const el = document.createElement("div");
            el.className = `msg ${item.role === "assistant" ? "assistant" : item.role === "user" ? "user" : "system"}`;
            el.textContent = item.text;
            chatFeedEl.appendChild(el);
            continue;
          }
          if (item.kind === "thought" && showInlineActivity) {
            const th = document.createElement("div");
            th.className = "msg inline-thought";
            th.textContent = `(thinking) ${item.text}`;
            chatFeedEl.appendChild(th);
          }
        }
        chatPaneEl.scrollTop = chatPaneEl.scrollHeight;
      }

      function renderActivity() {
        activityFeedEl.innerHTML = "";
        if (!selectedChatId) return;
        for (const a of getState(selectedChatId).activity) {
          const el = document.createElement("div");
          el.className = "act";
          el.innerHTML = `<span class=\"ts\">${fmtTs(a.ts)}</span><span class=\"tag\">${a.provider || "runtime"}:${a.stage}</span>${a.detail}`;
          activityFeedEl.appendChild(el);
        }
        activityPaneEl.scrollTop = activityPaneEl.scrollHeight;
      }

      function initTerminal() {
        if (window.Terminal && window.FitAddon && window.FitAddon.FitAddon) {
          term = new Terminal({
            cursorBlink: true,
            convertEol: false,
            fontFamily: "Menlo, Monaco, 'Courier New', monospace",
            fontSize: 14,
            theme: { background: "#050d24", foreground: "#d1fae5" },
          });
          fitAddon = new FitAddon.FitAddon();
          term.loadAddon(fitAddon);
          term.open(terminalEl);
          fitAddon.fit();
          useXterm = true;
          return;
        }
        terminalEl.style.whiteSpace = "pre-wrap";
        terminalEl.style.overflow = "auto";
        terminalEl.style.color = "#d1fae5";
      }

      function writeTerm(text) {
        if (useXterm && term) term.write(text || "");
        else terminalEl.textContent += text || "";
      }

      async function request(path, options = {}) {
        const res = await fetch(path, {
          headers: { "Content-Type": "application/json" },
          ...options,
        });
        if (!res.ok) throw new Error(await res.text());
        return res.json();
      }

      function setMode(next) {
        mode = next;
        terminalPaneEl.classList.toggle("hidden", mode !== "terminal");
        chatPaneEl.classList.toggle("hidden", mode !== "chat");
        activityPaneEl.classList.toggle("hidden", mode !== "activity");
        document.getElementById("mode-terminal").classList.toggle("active", mode === "terminal");
        document.getElementById("mode-chat").classList.toggle("active", mode === "chat");
        document.getElementById("mode-activity").classList.toggle("active", mode === "activity");
        if (mode === "chat") renderChat();
        if (mode === "activity") renderActivity();
        if (mode === "terminal") syncSize().catch(console.error);
      }

      async function syncSize() {
        if (!selectedChatId || !useXterm || !fitAddon || !term) return;
        fitAddon.fit();
        await request(`/api/chats/${selectedChatId}/resize`, {
          method: "POST",
          body: JSON.stringify({ cols: term.cols, rows: term.rows }),
        });
      }

      function renderChats() {
        chatListEl.innerHTML = "";
        for (const chat of chats) {
          const item = document.createElement("div");
          item.className = "chat-item" + (chat.id === selectedChatId ? " active" : "");
          item.textContent = chat.title;
          item.onclick = () => selectChat(chat.id);
          chatListEl.appendChild(item);
        }
      }

      async function sendRaw(data) {
        if (!selectedChatId || !data) return;
        await request(`/api/chats/${selectedChatId}/input`, {
          method: "POST",
          body: JSON.stringify({ text: data }),
        });
      }

      function queueRaw(data) {
        keyBuffer += data;
        if (keyFlushTimer) return;
        keyFlushTimer = setTimeout(async () => {
          const payload = keyBuffer;
          keyBuffer = "";
          keyFlushTimer = null;
          try {
            await sendRaw(payload);
          } catch (err) {
            console.error(err);
          }
        }, 20);
      }

      function connectStream(chatId) {
        if (stream) stream.close();
        getState(chatId);
        if (useXterm && term) {
          term.reset();
          term.clear();
        } else {
          terminalEl.textContent = "";
        }
        stream = new EventSource(`/api/chats/${chatId}/events`);
        stream.addEventListener("output", (ev) => {
          const p = JSON.parse(ev.data);
          writeTerm(p.text || "");
          if (executionMode === "interactive") {
            mirrorInteractiveOutput(chatId, p.text || "");
          }
        });
        stream.addEventListener("status", (ev) => {
          const p = JSON.parse(ev.data);
          writeTerm(`\r\n[session ${p.state}]\r\n`);
          pushActivity(chatId, `session_${p.state}`, "runtime", "status", p.ts);
          if (executionMode === "interactive" && p.state === "stopped") {
            commitInteractiveDraft(chatId, true);
          }
        });
        stream.addEventListener("activity", (ev) => {
          const p = JSON.parse(ev.data);
          pushActivity(chatId, p.detail || "activity", p.provider || "agent", p.stage || "stream", p.ts);
        });
        stream.addEventListener("chat", (ev) => {
          const p = JSON.parse(ev.data);
          pushMessage(chatId, p.role || "assistant", p.text || "", p.provider || "agent", p.ts);
        });
        stream.addEventListener("thought", (ev) => {
          const p = JSON.parse(ev.data);
          pushThought(chatId, p.text || "", p.provider || "agent", p.ts);
        });
        stream.onerror = () => {
          pushActivity(chatId, "stream_disconnected", "runtime", "error", Date.now());
        };
        stream.onopen = () => {
          syncSize().catch(console.error);
        };
      }

      function selectChat(chatId) {
        selectedChatId = chatId;
        const c = chats.find((x) => x.id === chatId);
        titleEl.textContent = c ? c.title : "Unknown chat";
        renderChats();
        connectStream(chatId);
        renderChat();
        renderActivity();
      }

      async function newChat() {
        const name = `chat-${Date.now().toString().slice(-4)}`;
        const data = await request("/api/chats", {
          method: "POST",
          body: JSON.stringify({ title: name }),
        });
        chats.push(data.chat);
        renderChats();
        selectChat(data.chat.id);
      }

      async function refreshChats() {
        const data = await request("/api/chats");
        chats = data.chats;
        renderChats();
        if (!selectedChatId && chats.length > 0) {
          selectChat(chats[0].id);
          return;
        }
        if (!selectedChatId && chats.length === 0) {
          await newChat();
        }
      }

      async function sendComposer() {
        const text = inputEl.value;
        if (!selectedChatId || !text.trim()) return;
        inputEl.value = "";
        if (mode === "terminal" || executionMode === "interactive") {
          beginInteractiveTurn(selectedChatId, text.trim());
          if (mode !== "terminal") {
            pushMessage(selectedChatId, "user", text.trim(), "interactive", Date.now());
            pushActivity(selectedChatId, "sent_to_interactive_terminal", "runtime", "submit", Date.now());
          }
          await sendRaw(text + "\r");
          return;
        }
        const parsed = resolveProviderAndPrompt(text);
        if (!parsed.prompt) return;
        pushMessage(selectedChatId, "user", parsed.prompt, parsed.provider, Date.now());
        pushActivity(selectedChatId, `task_submitted (${parsed.provider})`, parsed.provider, "submit", Date.now());
        try {
          await request(`/api/chats/${selectedChatId}/tasks`, {
            method: "POST",
            body: JSON.stringify({ provider: parsed.provider, prompt: parsed.prompt }),
          });
        } catch (err) {
          pushMessage(selectedChatId, "system", `Failed to submit task: ${String(err)}`, parsed.provider, Date.now());
        }
      }

      initTerminal();
      document.getElementById("new-chat").onclick = newChat;
      document.getElementById("send").onclick = sendComposer;
      document.getElementById("mode-terminal").onclick = () => setMode("terminal");
      document.getElementById("mode-chat").onclick = () => setMode("chat");
      document.getElementById("mode-activity").onclick = () => setMode("activity");
      inlineToggleEl.onclick = () => {
        showInlineActivity = !showInlineActivity;
        inlineToggleEl.classList.toggle("on", showInlineActivity);
        inlineToggleEl.textContent = showInlineActivity ? "Intermediate On" : "Intermediate Off";
        if (mode === "chat") renderChat();
      };
      executionToggleEl.onclick = () => {
        executionMode = executionMode === "interactive" ? "structured" : "interactive";
        executionToggleEl.classList.toggle("on", executionMode === "interactive");
        executionToggleEl.textContent = executionMode === "interactive" ? "Exec: Interactive" : "Exec: Structured";
      };

      if (useXterm && term) {
        term.onData((data) => {
          queueRaw(data);
        });
      }

      window.addEventListener("resize", () => {
        syncSize().catch(console.error);
      });

      inputEl.addEventListener("keydown", (ev) => {
        if (ev.key === "Enter" && !ev.shiftKey) {
          ev.preventDefault();
          sendComposer();
        }
      });

      refreshChats().catch(console.error);
    </script>
  </body>
</html>
